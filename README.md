## Conceptos de Algoritmos, Datos y Programas

### :books: Teorias:
* [Clase 1](https://github.com/Caarito/Materia-CADP/blob/main/Teorias/teoria_1.pdf) :open_book:
* [Clase 2](https://github.com/Caarito/Materia-CADP/blob/main/Teorias/teoria_2.pdf) :open_book:
* [Clase 3](https://github.com/Caarito/Materia-CADP/blob/main/Teorias/teoria_3.pdf) :open_book:
* [Clase 4](https://github.com/Caarito/Materia-CADP/blob/main/Teorias/teoria_4.pdf) :open_book:
* [Clase 5](https://github.com/Caarito/Materia-CADP/blob/main/Teorias/teoria_5.pdf) :open_book:
* [Clase 6](https://github.com/Caarito/Materia-CADP/blob/main/Teorias/teoria_6.pdf) :open_book:
* [Clase 7](https://github.com/Caarito/Materia-CADP/blob/main/Teorias/teoria_7.pdf) :open_book:
* [Clase 8](https://github.com/Caarito/Materia-CADP/blob/main/Teorias/teoria_8.pdf) :open_book:
* [Clase 9](https://github.com/Caarito/Materia-CADP/blob/main/Teorias/teoria_9.pdf) :open_book:
* [Clase 10](https://github.com/Caarito/Materia-CADP/blob/main/Teorias/teoria_10.pdf) :open_book:
* [Clase 11](https://github.com/Caarito/Materia-CADP/blob/main/Teorias/teoria_11.pdf) :open_book:
* [Clase 12](https://github.com/Caarito/Materia-CADP/blob/main/Teorias/teroria_12.pdf) :open_book:




### :clapper: Videos:
* [TeorÃ­as](https://www.youtube.com/playlist?list=PL3a_0yafSm3irdB7iRbCrGRpPJ8rAV6KW) :film_strip:
* [PrÃ¡cticas](https://www.youtube.com/playlist?list=PL3a_0yafSm3hc9tnmNHnjtj93x2S8H1dY) :film_strip:

 ### ðŸ’» Practicas: 
 
 * [Practica 1](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%201/Practica%201%20cadp.pdf) :page_facing_up:
     - [Ejercicio 1](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%201/Resoluci%C3%B3n%20Practica/punto1.pas) :computer:      
     - [Ejercicio 2](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%201/Resoluci%C3%B3n%20Practica/punto2.pas) :computer:
     - [Ejercicio 3](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%201/Resoluci%C3%B3n%20Practica/punto3.pas) :computer:
     - [Ejercicio 4](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%201/Resoluci%C3%B3n%20Practica/punto4.pas) :computer:
     - [Ejercicio 5](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%201/Resoluci%C3%B3n%20Practica/punto5.pas) :computer:
     - [Ejercicio 6](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%201/Resoluci%C3%B3n%20Practica/punto6.pas) :computer:
     - [Ejercicio 7](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%201/Resoluci%C3%B3n%20Practica/punto7.pas) :computer:
     - [Ejercicio 8](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%201/Resoluci%C3%B3n%20Practica/punto8.pas) :computer:
     - [Ejercicio 9](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%201/Resoluci%C3%B3n%20Practica/punto9.pas) :computer:
     
 * [Practica 2](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%202/Practica_2.pdf) :page_facing_up:     
     - [Ejercicio 1](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%202/Resoluci%C3%B3n%20Practica/punto1.pas) :computer:
     - [Ejercicio 1.a](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%202/Resoluci%C3%B3n%20Practica/punto1a.pas) :computer:      
     - [Ejercicio 2](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%202/Resoluci%C3%B3n%20Practica/punto2.pas) :computer:
     - [Ejercicio 2.a](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%202/Resoluci%C3%B3n%20Practica/punto2a.pas) :computer:
     - [Ejercicio 3](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%202/Resoluci%C3%B3n%20Practica/punto3.pas) :computer:
     - [Ejercicio 4](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%202/Resoluci%C3%B3n%20Practica/punto4.pas) :computer:
     - [Ejercicio 4.a](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%202/Resoluci%C3%B3n%20Practica/punto4a.pas) :computer:
     - [Ejercicio 4.b](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%202/Resoluci%C3%B3n%20Practica/punto4b.pas) :computer:
     - [Ejercicio 5](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%202/Resoluci%C3%B3n%20Practica/punto5.pas) :computer:
     - [Ejercicio 6](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%202/Resoluci%C3%B3n%20Practica/punto6.pas) :computer:
     - [Ejercicio 7](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%202/Resoluci%C3%B3n%20Practica/punto7.pas) :computer:
     - [Ejercicio 7.a](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%202/Resoluci%C3%B3n%20Practica/punto7a.pas) :computer:
     
          
 * [Practica 3](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%203/practica_3.pdf) :page_facing_up:     
     - [Ejercicio 1](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%203/Resoluci%C3%B3n%20Practica/punto1.pas) :computer:  
     - [Ejercicio 2](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%203/Resoluci%C3%B3n%20Practica/punto2.pas) :computer:
     - [Ejercicio 3](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%203/Resoluci%C3%B3n%20Practica/punto3.pas) :computer:  
     - [Ejercicio 4](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%203/Resoluci%C3%B3n%20Practica/punto4.pas) :computer:
     - [Ejercicio 5](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%203/Resoluci%C3%B3n%20Practica/punto5.pas) :computer:
     - [Ejercicio 6](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%203/Resoluci%C3%B3n%20Practica/punto6.pas) :computer:
     - [Ejercicio 7](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%203/Resoluci%C3%B3n%20Practica/punto7.pas) :computer:
     - [Ejercicio 8](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%203/Resoluci%C3%B3n%20Practica/punto8.pas) :computer:
     - [Ejercicio 9](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%203/Resoluci%C3%B3n%20Practica/punto9.pas) :computer:
     - [Ejercicio 10](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%203/Resoluci%C3%B3n%20Practica/punto10.pas) :computer:
     - [Ejercicio 11](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%203/Resoluci%C3%B3n%20Practica/punto11.pas) :computer:

* [Practica 4.1](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%204.1/Practica_4.1.pdf) :page_facing_up:     
     - [Ejercicio 1](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%204.1/Resoluci%C3%B3n%20Practica/4.1.pas) :computer:  
     - [Ejercicio 2](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%204.1/Resoluci%C3%B3n%20Practica/4.2.pas) :computer:
     - [Ejercicio 3](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%204.1/Resoluci%C3%B3n%20Practica/4.3.pas) :computer:  
     - [Ejercicio 4](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%204.1/Resoluci%C3%B3n%20Practica/4.4.pas) :computer:
     - [Ejercicio 5](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%204.1/Resoluci%C3%B3n%20Practica/4.5.pas) :computer:
     - [Ejercicio 6](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%204.1/Resoluci%C3%B3n%20Practica/4.6.pas) :computer:
     - [Ejercicio 7](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%204.1/Resoluci%C3%B3n%20Practica/4.7.pas) :computer:
     - [Ejercicio 8](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%204.1/Resoluci%C3%B3n%20Practica/4.8.pas) :computer:
     - [Ejercicio 9](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%204.1/Resoluci%C3%B3n%20Practica/4.9.pas) :computer:
     - [Ejercicio 10](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%204.1/Resoluci%C3%B3n%20Practica/4.10.pas) :computer:
     - [Ejercicio 11](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%204.1/Resoluci%C3%B3n%20Practica/4.11.pas) :computer:
     - [Ejercicio 12](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%204.1/Resoluci%C3%B3n%20Practica/4.12.pas) :computer:
     - [Ejercicio 13](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%204.1/Resoluci%C3%B3n%20Practica/4.13.pas) :computer:

### **CODIGOS UTILES / LISTAS Y VECTORES**
___
#### **LISTAS:**
AGREGA ELEMENTO AL FINAL DE LA LISTA DE MANERA EFICIENTE:
```pascal
procedure agregar_ATRAS_eficiente(var l: lista; var ult: lista; dato: integer);
var
  nue: lista;
begin
  new(nue);
  nue^.elem := dato;
  nue^.sig := nil;
  if l = nil then
    l := nue
  else
    ult^.sig := nue;
  ult := nue;
end;
```
AGREGA ELEMENTO AL FINAL DE LA LISTA DE MANERA MENOS EFICIENTE:
```pascal
procedure agregar_ATRAS_no_eficiente(var l: lista; dato: integer);
var
  nue: lista;
  ant: lista;
  act: lista;
begin
  new(nue);
  nue^.elem := dato;
  nue^.sig := nil;
  act := l;
  ant := nil;
  while (act <> nil) do
  begin
    ant := act;
    act := act^.sig;
  end;
  if (ant = nil) then
    l := nue
  else
    ant^.sig := nue;
  nue^.sig := act;
end;
```
AGREGA ELEMENTO ADELANTE EN LA LISTA:
```pascal
procedure agregar_adelante(var l: lista; dato: integer);
var
  nue: lista;
begin
  new(nue);
  nue^.elem := dato;
  nue^.sig := l;
  l := nue;
end;
```
AGREGA ELEMENTO DE MANERA ORDENADO EN LA LISTA:
```pascal
procedure insertar_ordenado(var l: lista; var dato: integer);
var
  nue: lista;
  ant: lista;
  act: lista;
begin
  new(nue);
  nue^.elem := dato;
  nue^.sig := nil;

  if (l = nil) then
  begin
    l := nue;
  end
  else
  begin
    ant := nil; // Inicializar "ant" con nil
    act := l;
    while (act <> nil) and (act^.elem < nue^.elem) do
    begin
      ant := act;
      act := act^.sig;
    end;
  end;

  if (ant = nil) then
  begin
    nue^.sig := l;
    l := nue;
  end
  else
  begin
    ant^.sig := nue;
    nue^.sig := act;
  end;
end;
```

ELIMINACION DE UN ELEMENTO EN LA LISTA:
```pascal
{En este caso puede existir o no un booleano para confirmar si se elimino o no el elemento
dependerÃ¡ del enunciado .  Ejemplo sin booleano:}

procedure eliminar_elemento(var l: lista; num: integer);
var
  act: lista;
  ant: lista;
begin
  act := l;
  ant := nil; // Inicializar "ant" con nil

  while (act <> nil) and (act^.elem <> num) do
  begin
    ant := act;
    act := act^.sig;
  end;

  if (act <> nil) then
  begin
    if (l = act) then
    begin
      l := act^.sig;
    end
    else
    begin
      ant^.sig := act^.sig;
    end;
    dispose(act);
  end;
end;
```
BUSCAR UN ELEMENTO EN LISTA DESORDENADA :
```pascal
function buscar_elemento_desordenado(l: lista; num: integer): boolean;
var
  act: lista;
  encontrado: boolean;
begin
  act := l;
  encontrado := false;
  while (act <> nil) and (encontrado = false) do
  begin
    if (act^.elem = num) then
    begin
      encontrado := true;
    end
    else
    begin
      act := act^.sig;
    end;
  end;
  buscar_elemento_desordenado := encontrado;
end;
```
BUSCAR UN ELEMENTO EN UNA LISTA ORDENADA:
```pascal
function buscar_elemento_ordenado(l: lista; num: integer): boolean;
var
  act: lista;
  encontrado: boolean;
begin
  act := l;
  encontrado := false;
  while (act <> nil) and (act^.elem < num) do
  begin
    act := act^.sig;
  end;

  if (act <> nil) and (act^.elem = num) then
  begin
    encontrado := true;
  end;
  buscar_elemento_ordenado := encontrado;
end;
```
___
#### **LISTAS:**
CARGA TOTAL DEL VECTOR:
```pascal
procedure cargar_total_vector(var v: vector);
var
  i: integer;
begin
  for i := 1 to dimF do begin
    readln(v[i]);
  end;
end;
```
CARGA PARCIAL DEL VECTOR:
```pascal
procedure cargar_vector_parcial(var v: vector; var diml: integer);
var
  i: integer;
  num: integer;
begin
  i := 1;
  read(num);
  while (diml < dimf) do begin
    v[diml] := num;
    diml := diml + 1;
    read(num);
  end;
end;
```
VALIDA UNA POSCION DE UN ELEMENTO EN EL VECTOR QUE PODRIA NO EXISTIR:
```pascal
function posicion_puede_no_existir(v: vector): integer;
var
  pos: integer;
  cumple: boolean;
begin
  pos := 1;
  cumple := false;

  while (pos <= diml) and (cumple = false) do begin
    if (v[pos] = 2) then begin
      cumple := true;
    end
    else
    begin
      pos := pos + 1;
    end;
  end;

  if cumple then begin
    posicion_puede_no_existir := pos;
  end
  else begin
    pos := -1;
    posicion_puede_no_existir := pos;
  end;
end;
```
VALIDA UNA POSCION DE UN ELEMENTO EN EL VECTOR QUE SEGURO EXISTE:
```pascal
function posicion_seguro_existe(v: vector): integer;
var
  pos: integer;
  cumple: boolean;
begin
  pos := 1;
  cumple := false;
  while (cumple = false) do begin
    if (v[pos] = 2) then begin
      cumple := true;
    end
    else
    begin
      pos := pos + 1;
    end;
  end;
  posicion_seguro_existe := pos;
end;
```
AGREGA UN ELEMENTO AL FINAL DEL VECTOR:
```pascal
procedure agregar_final(var v: vector; var diml: integer; elem: integer; var pude: boolean);
begin
  pude := false;
  if (diml + 1 <= dimf) then begin
    pude := true;
    diml := diml + 1;
    v[diml] := elem;
  end;
end;
```
INSERTA UN ELEMENTO EN EL VECTOR EN UNA POSICION DETERMINADA: 
```pascal
{insertar un elemento en un arreglo en una posiciÃ³n determinada, x:elemento en x:posiciÃ³n.

pasos:
1) validar que el vector tenga espacio suficiente
2) validar que la posiciÃ³n exista
3) hacer un corrimiento hacia la derecha de los elementos hasta la posiciÃ³n
4) insertar nuevo elemento 
5) incrementar la dimencion lÃ³gica.}

procedure insertar_en_vector(var v: vector; var diml: integer; elem: integer; pos: integer; var cumple: boolean);
var
  i: integer;
begin
  cumple := false;
  if (diml < dimf) and (pos >= 1) and (pos <= diml) then
  begin
    for i := diml downto pos + 1 do 
      v[i] := v[i - 1];

    v[pos] := elem;
    diml := diml + 1;
    cumple := true;
  end;
end;
```
ELIMINACION DE UNA POSCION EN EL VECTOR:
```pascal
{eliminar una posiciÃ³n en un arreglo.

pasos:
1)verificar que la posiciÃ³n sea valida
2)hacer un corrimiento hacia la izquierda desde pos hasta diml-1
3)disminuir diml en uno.}

procedure eliminar_pos_arreglo(var v: vector; var diml: integer; pos: integer; var cumple: boolean);
var
  i: integer;
begin
  cumple := false;
  if (pos >= 1) and (pos <= diml) then begin
    for i := pos to diml - 1 do begin
      v[i] := v[i + 1]; 
    cumple := true;
    diml := diml - 1;
  end;
end;
```
ELIMINACION DE UN ELEMENTO EN EL VECTOR:
```pascal
procedure eliminar_elem_arreglo(var v: vector; var diml: integer; elem: integer; var cumple: boolean);
var
  i, pos: integer;
begin
  cumple := false;
  pos := 1;
  while (pos >= 1) and (pos <= diml) and (not cumple) do begin
    if (v[pos] = elem) then begin
      for i := pos to diml - 1 do begin
        v[i] := v[i + 1];
      end;
      cumple := true;
      diml := diml - 1;
    end
    else
    begin
      pos := pos + 1;
    end;
  end;
end;
```
BUSQUEDA DE UN ELEMENTO EN UN VECTOR DESORDENADO:
```pascal
function bÃºsqueda_desordenada(v: vector; diml: integer; elem: integer): boolean;
var
  cumple: boolean;
  pos: integer;
begin
  cumple := false;
  pos := 1;
  while (pos >= 1) and (pos <= diml) and (not cumple) do begin
    if (v[pos] = elem) then begin
      cumple := true;
    end
    else
    begin
      pos := pos + 1;
    end;
  end;
  bÃºsqueda_desordenada := cumple;
end;
```
BUSQUEDA UN ELEMENTO EN UN VECTOR ORDENADO DE MANERA SECUENCIAL:
```pascal
function bÃºsqueda_ordenada_secuencial(v: vector; diml: integer; elem: integer): boolean;
var
  cumple: boolean;
  pos: integer;
begin
  cumple := false;
  pos := 1;
  while (pos >= 1) and (pos <= diml) and (v[pos] < elem) do begin
    pos := pos + 1;
  end;

  if (pos <= diml) and (v[pos] = elem) then begin
    cumple := true;
  end;
  bÃºsqueda_ordenada_secuencial := cumple;
end;

{En el ultimo if siempre van las dos condiciones, si pos se mayor a diml cuando sale del while y solo preguntara por V[POS]=ELEM , estaria preguntando por una posicion invalida ya que pos seria mayor a diml}
```
BUSQUEDA DICOTOMICA VECTOR:
```pascal
{La funciÃ³n busquedaDicotomica implementa el algoritmo de bÃºsqueda dicotÃ³mica 
y devuelve el Ã­ndice donde se encuentra el valor en el vector
o -1 si no se encuentra.}

function busqueda_dicotomica(v:vector; valor: Integer):Integer;
var
  inicio:integer;
  medio:integer;
  fin:integer;
  aux:integer;
  cumple:Boolean;
begin
  cumple:false;
  inicio := 1;
  fin:= dimf; // dimf variable constante
  while (inicio <= fin) and not (cumple)do begin
    medio:=(inicio + fin) div 2; 
    if (v[medio] = valor) then begin
      cumple:=True;
      aux:=(medio); // Se encontrÃ³ el valor 
    else 
      if (v[medio] < valor) then
        inicio:= medio + 1 // El valor estÃ¡ en la mitad derecha
      else
        fin:= medio - 1; // El valor estÃ¡ en la mitad izquierda
  end;
  if (cumple) then 
    busqueda_dicotomica:=aux;
  else
    busqueda_dicotomica:=-1;  // El valor no se encontrÃ³
end;
```   
