## Conceptos de Algoritmos, Datos y Programas

### :books: Teorias:
* [Clase 1](https://github.com/Caarito/Materia-CADP/blob/main/Teorias/teoria_1.pdf) :open_book:
* [Clase 2](https://github.com/Caarito/Materia-CADP/blob/main/Teorias/teoria_2.pdf) :open_book:
* [Clase 3](https://github.com/Caarito/Materia-CADP/blob/main/Teorias/teoria_3.pdf) :open_book:
* [Clase 4](https://github.com/Caarito/Materia-CADP/blob/main/Teorias/teoria_4.pdf) :open_book:
* [Clase 5](https://github.com/Caarito/Materia-CADP/blob/main/Teorias/teoria_5.pdf) :open_book:
* [Clase 6](https://github.com/Caarito/Materia-CADP/blob/main/Teorias/teoria_6.pdf) :open_book:
* [Clase 7](https://github.com/Caarito/Materia-CADP/blob/main/Teorias/teoria_7.pdf) :open_book:
* [Clase 8](https://github.com/Caarito/Materia-CADP/blob/main/Teorias/teoria_8.pdf) :open_book:
* [Clase 9](https://github.com/Caarito/Materia-CADP/blob/main/Teorias/teoria_9.pdf) :open_book:
* [Clase 10](https://github.com/Caarito/Materia-CADP/blob/main/Teorias/teoria_10.pdf) :open_book:
* [Clase 11](https://github.com/Caarito/Materia-CADP/blob/main/Teorias/teoria_11.pdf) :open_book:
* [Clase 12](https://github.com/Caarito/Materia-CADP/blob/main/Teorias/teroria_12.pdf) :open_book:




### :clapper: Videos:
* [Teor铆as](https://www.youtube.com/playlist?list=PL3a_0yafSm3irdB7iRbCrGRpPJ8rAV6KW) :film_strip:
* [Pr谩cticas](https://www.youtube.com/playlist?list=PL3a_0yafSm3hc9tnmNHnjtj93x2S8H1dY) :film_strip:

 ###  Practicas: 
 
 * [Practica 1](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%201/Practica%201%20cadp.pdf) :page_facing_up:
     - [Ejercicio 1](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%201/Resoluci%C3%B3n%20Practica/punto1.pas) :computer:      
     - [Ejercicio 2](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%201/Resoluci%C3%B3n%20Practica/punto2.pas) :computer:
     - [Ejercicio 3](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%201/Resoluci%C3%B3n%20Practica/punto3.pas) :computer:
     - [Ejercicio 4](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%201/Resoluci%C3%B3n%20Practica/punto4.pas) :computer:
     - [Ejercicio 5](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%201/Resoluci%C3%B3n%20Practica/punto5.pas) :computer:
     - [Ejercicio 6](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%201/Resoluci%C3%B3n%20Practica/punto6.pas) :computer:
     - [Ejercicio 7](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%201/Resoluci%C3%B3n%20Practica/punto7.pas) :computer:
     - [Ejercicio 8](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%201/Resoluci%C3%B3n%20Practica/punto8.pas) :computer:
     - [Ejercicio 9](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%201/Resoluci%C3%B3n%20Practica/punto9.pas) :computer:
     
 * [Practica 2](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%202/Practica_2.pdf) :page_facing_up:     
     - [Ejercicio 1](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%202/Resoluci%C3%B3n%20Practica/punto1.pas) :computer:
     - [Ejercicio 1.a](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%202/Resoluci%C3%B3n%20Practica/punto1a.pas) :computer:      
     - [Ejercicio 2](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%202/Resoluci%C3%B3n%20Practica/punto2.pas) :computer:
     - [Ejercicio 2.a](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%202/Resoluci%C3%B3n%20Practica/punto2a.pas) :computer:
     - [Ejercicio 3](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%202/Resoluci%C3%B3n%20Practica/punto3.pas) :computer:
     - [Ejercicio 4](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%202/Resoluci%C3%B3n%20Practica/punto4.pas) :computer:
     - [Ejercicio 4.a](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%202/Resoluci%C3%B3n%20Practica/punto4a.pas) :computer:
     - [Ejercicio 4.b](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%202/Resoluci%C3%B3n%20Practica/punto4b.pas) :computer:
     - [Ejercicio 5](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%202/Resoluci%C3%B3n%20Practica/punto5.pas) :computer:
     - [Ejercicio 6](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%202/Resoluci%C3%B3n%20Practica/punto6.pas) :computer:
     - [Ejercicio 7](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%202/Resoluci%C3%B3n%20Practica/punto7.pas) :computer:
     - [Ejercicio 7.a](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%202/Resoluci%C3%B3n%20Practica/punto7a.pas) :computer:
     
          
 * [Practica 3](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%203/practica_3.pdf) :page_facing_up:     
     - [Ejercicio 1](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%203/Resoluci%C3%B3n%20Practica/punto1.pas) :computer:  
     - [Ejercicio 2](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%203/Resoluci%C3%B3n%20Practica/punto2.pas) :computer:
     - [Ejercicio 3](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%203/Resoluci%C3%B3n%20Practica/punto3.pas) :computer:  
     - [Ejercicio 4](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%203/Resoluci%C3%B3n%20Practica/punto4.pas) :computer:
     - [Ejercicio 5](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%203/Resoluci%C3%B3n%20Practica/punto5.pas) :computer:
     - [Ejercicio 6](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%203/Resoluci%C3%B3n%20Practica/punto6.pas) :computer:
     - [Ejercicio 7](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%203/Resoluci%C3%B3n%20Practica/punto7.pas) :computer:
     - [Ejercicio 8](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%203/Resoluci%C3%B3n%20Practica/punto8.pas) :computer:
     - [Ejercicio 9](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%203/Resoluci%C3%B3n%20Practica/punto9.pas) :computer:
     - [Ejercicio 10](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%203/Resoluci%C3%B3n%20Practica/punto10.pas) :computer:
     - [Ejercicio 11](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%203/Resoluci%C3%B3n%20Practica/punto11.pas) :computer:

* [Practica 4.1](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%204.1/Practica_4.1.pdf) :page_facing_up:     
     - [Ejercicio 1](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%204.1/Resoluci%C3%B3n%20Practica/4.1.pas) :computer:  
     - [Ejercicio 2](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%204.1/Resoluci%C3%B3n%20Practica/4.2.pas) :computer:
     - [Ejercicio 3](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%204.1/Resoluci%C3%B3n%20Practica/4.3.pas) :computer:  
     - [Ejercicio 4](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%204.1/Resoluci%C3%B3n%20Practica/4.4.pas) :computer:
     - [Ejercicio 5](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%204.1/Resoluci%C3%B3n%20Practica/4.5.pas) :computer:
     - [Ejercicio 6](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%204.1/Resoluci%C3%B3n%20Practica/4.6.pas) :computer:
     - [Ejercicio 7](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%204.1/Resoluci%C3%B3n%20Practica/4.7.pas) :computer:
     - [Ejercicio 8](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%204.1/Resoluci%C3%B3n%20Practica/4.8.pas) :computer:
     - [Ejercicio 9](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%204.1/Resoluci%C3%B3n%20Practica/4.9.pas) :computer:
     - [Ejercicio 10](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%204.1/Resoluci%C3%B3n%20Practica/4.10.pas) :computer:
     - [Ejercicio 11](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%204.1/Resoluci%C3%B3n%20Practica/4.11.pas) :computer:
     - [Ejercicio 12](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%204.1/Resoluci%C3%B3n%20Practica/4.12.pas) :computer:
     - [Ejercicio 13](https://github.com/Caarito/Materia-CADP/blob/main/Practicas/Practica%204.1/Resoluci%C3%B3n%20Practica/4.13.pas) :computer:

### **CODIGOS UTILES / LISTAS Y VECTORES**
___
#### **LISTAS:**
AGREGA ELEMENTO AL FINAL DE LA LISTA DE MANERA EFICIENTE:
```pascal
procedure agregar_ATRAS_eficiente(var l: lista; var ult: lista; dato: integer);
var
  nue: lista;
begin
  new(nue);
  nue^.elem := dato;
  nue^.sig := nil;
  if l = nil then
    l := nue
  else
    ult^.sig := nue;
  ult := nue;
end;
```
AGREGA ELEMENTO AL FINAL DE LA LISTA DE MANERA MENOS EFICIENTE:
```pascal
procedure agregar_ATRAS_no_eficiente(var l: lista; dato: integer);
var
  nue: lista;
  ant: lista;
  act: lista;
begin
  new(nue);
  nue^.elem := dato;
  nue^.sig := nil;
  act := l;
  ant := nil;
  while (act <> nil) do
  begin
    ant := act;
    act := act^.sig;
  end;
  if (ant = nil) then
    l := nue
  else
    ant^.sig := nue;
  nue^.sig := act;
end;
```
AGREGA ELEMENTO ADELANTE EN LA LISTA:
```pascal
procedure agregar_adelante(var l: lista; dato: integer);
var
  nue: lista;
begin
  new(nue);
  nue^.elem := dato;
  nue^.sig := l;
  l := nue;
end;
```
AGREGA ELEMENTO DE MANERA ORDENADO EN LA LISTA:
```pascal
procedure insertar_ordenado(var l: lista; var dato: integer);
var
  nue: lista;
  ant: lista;
  act: lista;
begin
  new(nue);
  nue^.elem := dato;
  nue^.sig := nil;

  if (l = nil) then
  begin
    l := nue;
  end
  else
  begin
    ant := nil; // Inicializar "ant" con nil
    act := l;
    while (act <> nil) and (act^.elem < nue^.elem) do
    begin
      ant := act;
      act := act^.sig;
    end;
  end;

  if (ant = nil) then
  begin
    nue^.sig := l;
    l := nue;
  end
  else
  begin
    ant^.sig := nue;
    nue^.sig := act;
  end;
end;
```

ELIMINACION DE UN ELEMENTO EN LA LISTA:
```pascal
{En este caso puede existir o no un booleano para confirmar si se elimino o no el elemento
depender谩 del enunciado .  Ejemplo sin booleano:}

procedure eliminar_elemento(var l: lista; num: integer);
var
  act: lista;
  ant: lista;
begin
  act := l;
  ant := nil; // Inicializar "ant" con nil

  while (act <> nil) and (act^.elem <> num) do
  begin
    ant := act;
    act := act^.sig;
  end;

  if (act <> nil) then
  begin
    if (l = act) then
    begin
      l := act^.sig;
    end
    else
    begin
      ant^.sig := act^.sig;
    end;
    dispose(act);
  end;
end;
```
BUSCAR UN ELEMENTO EN LISTA DESORDENADA :
```pascal
function buscar_elemento_desordenado(l: lista; num: integer): boolean;
var
  act: lista;
  encontrado: boolean;
begin
  act := l;
  encontrado := false;
  while (act <> nil) and (encontrado = false) do
  begin
    if (act^.elem = num) then
    begin
      encontrado := true;
    end
    else
    begin
      act := act^.sig;
    end;
  end;
  buscar_elemento_desordenado := encontrado;
end;
```
BUSCAR UN ELEMENTO EN UNA LISTA ORDENADA:
```pascal
function buscar_elemento_ordenado(l: lista; num: integer): boolean;
var
  act: lista;
  encontrado: boolean;
begin
  act := l;
  encontrado := false;
  while (act <> nil) and (act^.elem < num) do
  begin
    act := act^.sig;
  end;

  if (act <> nil) and (act^.elem = num) then
  begin
    encontrado := true;
  end;
  buscar_elemento_ordenado := encontrado;
end;
```
___
#### **LISTAS:**
CARGA TOTAL DEL VECTOR:
```pascal
procedure cargar_total_vector(var v: vector);
var
  i: integer;
begin
  for i := 1 to dimF do begin
    readln(v[i]);
  end;
end;
```
CARGA PARCIAL DEL VECTOR:
```pascal
procedure cargar_vector_parcial(var v: vector; var diml: integer);
var
  i: integer;
  num: integer;
begin
  i := 1;
  read(num);
  while (diml < dimf) do begin
    v[diml] := num;
    diml := diml + 1;
    read(num);
  end;
end;
```
VALIDA UNA POSCION DE UN ELEMENTO EN EL VECTOR QUE PODRIA NO EXISTIR:
```pascal
function posicion_puede_no_existir(v: vector): integer;
var
  pos: integer;
  cumple: boolean;
begin
  pos := 1;
  cumple := false;

  while (pos <= diml) and (cumple = false) do begin
    if (v[pos] = 2) then begin
      cumple := true;
    end
    else
    begin
      pos := pos + 1;
    end;
  end;

  if cumple then begin
    posicion_puede_no_existir := pos;
  end
  else begin
    pos := -1;
    posicion_puede_no_existir := pos;
  end;
end;
```
VALIDA UNA POSCION DE UN ELEMENTO EN EL VECTOR QUE SEGURO EXISTE:
```pascal
function posicion_seguro_existe(v: vector): integer;
var
  pos: integer;
  cumple: boolean;
begin
  pos := 1;
  cumple := false;
  while (cumple = false) do begin
    if (v[pos] = 2) then begin
      cumple := true;
    end
    else
    begin
      pos := pos + 1;
    end;
  end;
  posicion_seguro_existe := pos;
end;
```
AGREGA UN ELEMENTO AL FINAL DEL VECTOR:
```pascal
procedure agregar_final(var v: vector; var diml: integer; elem: integer; var pude: boolean);
begin
  pude := false;
  if (diml + 1 <= dimf) then begin
    pude := true;
    diml := diml + 1;
    v[diml] := elem;
  end;
end;
```
INSERTA UN ELEMENTO EN EL VECTOR EN UNA POSICION DETERMINADA: 
```pascal
{insertar un elemento en un arreglo en una posici贸n determinada, x:elemento en x:posici贸n.

pasos:
1) validar que el vector tenga espacio suficiente
2) validar que la posici贸n exista
3) hacer un corrimiento hacia la derecha de los elementos hasta la posici贸n
4) insertar nuevo elemento 
5) incrementar la dimencion l贸gica.}

procedure insertar_en_vector(var v: vector; var diml: integer; elem: integer; pos: integer; var cumple: boolean);
var
  i: integer;
begin
  cumple := false;
  if (diml < dimf) and (pos >= 1) and (pos <= diml) then
  begin
    for i := diml downto pos + 1 do 
      v[i] := v[i - 1];

    v[pos] := elem;
    diml := diml + 1;
    cumple := true;
  end;
end;
```
ELIMINACION DE UNA POSCION EN EL VECTOR:
```pascal
{eliminar una posici贸n en un arreglo.

pasos:
1)verificar que la posici贸n sea valida
2)hacer un corrimiento hacia la izquierda desde pos hasta diml-1
3)disminuir diml en uno.}

procedure eliminar_pos_arreglo(var v: vector; var diml: integer; pos: integer; var cumple: boolean);
var
  i: integer;
begin
  cumple := false;
  if (pos >= 1) and (pos <= diml) then begin
    for i := pos to diml - 1 do begin
      v[i] := v[i + 1]; 
    cumple := true;
    diml := diml - 1;
  end;
end;
```
ELIMINACION DE UN ELEMENTO EN EL VECTOR:
```pascal
procedure eliminar_elem_arreglo(var v: vector; var diml: integer; elem: integer; var cumple: boolean);
var
  i, pos: integer;
begin
  cumple := false;
  pos := 1;
  while (pos >= 1) and (pos <= diml) and (not cumple) do begin
    if (v[pos] = elem) then begin
      for i := pos to diml - 1 do begin
        v[i] := v[i + 1];
      end;
      cumple := true;
      diml := diml - 1;
    end
    else
    begin
      pos := pos + 1;
    end;
  end;
end;
```
BUSQUEDA DE UN ELEMENTO EN UN VECTOR DESORDENADO:
```pascal
function b煤squeda_desordenada(v: vector; diml: integer; elem: integer): boolean;
var
  cumple: boolean;
  pos: integer;
begin
  cumple := false;
  pos := 1;
  while (pos >= 1) and (pos <= diml) and (not cumple) do begin
    if (v[pos] = elem) then begin
      cumple := true;
    end
    else
    begin
      pos := pos + 1;
    end;
  end;
  b煤squeda_desordenada := cumple;
end;
```
BUSQUEDA UN ELEMENTO EN UN VECTOR ORDENADO DE MANERA SECUENCIAL:
```pascal
function b煤squeda_ordenada_secuencial(v: vector; diml: integer; elem: integer): boolean;
var
  cumple: boolean;
  pos: integer;
begin
  cumple := false;
  pos := 1;
  while (pos >= 1) and (pos <= diml) and (v[pos] < elem) do begin
    pos := pos + 1;
  end;

  if (pos <= diml) and (v[pos] = elem) then begin
    cumple := true;
  end;
  b煤squeda_ordenada_secuencial := cumple;
end;

{En el ultimo if siempre van las dos condiciones, si pos se mayor a diml cuando sale del while y solo preguntara por V[POS]=ELEM , estaria preguntando por una posicion invalida ya que pos seria mayor a diml}
```
BUSQUEDA DICOTOMICA VECTOR:
```pascal
{La funci贸n busquedaDicotomica implementa el algoritmo de b煤squeda dicot贸mica 
y devuelve el 铆ndice donde se encuentra el valor en el vector
o -1 si no se encuentra.}

function busqueda_dicotomica(v:vector; valor: Integer):Integer;
var
  inicio:integer;
  medio:integer;
  fin:integer;
  aux:integer;
  cumple:Boolean;
begin
  cumple:false;
  inicio := 1;
  fin:= dimf; // dimf variable constante
  while (inicio <= fin) and not (cumple)do begin
    medio:=(inicio + fin) div 2; 
    if (v[medio] = valor) then begin
      cumple:=True;
      aux:=(medio); // Se encontr贸 el valor 
    else 
      if (v[medio] < valor) then
        inicio:= medio + 1 // El valor est谩 en la mitad derecha
      else
        fin:= medio - 1; // El valor est谩 en la mitad izquierda
  end;
  if (cumple) then 
    busqueda_dicotomica:=aux;
  else
    busqueda_dicotomica:=-1;  // El valor no se encontr贸
end;
```   
